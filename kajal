 public async getEnumsListByEnumtype(enumType: string): Promise<IZenvyEnum[]> {
    let baseUrl: string = this.getBaseUrl();
    let url = Utils.pathJoin([baseUrl + '/' + enumType]);
    const result$ = await this._http.get<IZenvyEnum[]>(url);
    const data = await lastValueFrom(result$);
    const sortedData = data.sort(
      (a, b) => Number(a.Sequence) - Number(b.Sequence)
    );
    return sortedData;
  }
 
  public async getEnumName(value: string, enumType: string): Promise<string> {
    if (Utils.isEmptyOrWhiteSpace(value)) {
      return '-';
    }
 
    await this.ensureEnumCached(enumType);
    const cachedEnum = this.cachedEnums.find(
      (cachedItem) => cachedItem.enumType === enumType
    );
    if (cachedEnum) {
      const item = cachedEnum.enumItems.find(
        (enumItem) => enumItem.Value === value
      );
      return item ? item.EnumName : '-';
    }
    return '-';
  }
 
  private async ensureEnumCached(enumType: string): Promise<void> {
    if (!this.isInCache(enumType)) {
      if (!this.fetchingEnums[enumType]) {
        this.fetchingEnums[enumType] = this.cacheEnums(enumType);
      }
      await this.fetchingEnums[enumType];
    }
  }
 
  private async cacheEnums(enumType: string): Promise<void> {
    try {
      const enumItems: IZenvyEnum[] = await this.getEnumsListByEnumtype(
        enumType
      );
      const cachedEnum: IEnumCached = {
        enumType: enumType,
        enumItems: enumItems,
      };
      this.cachedEnums.push(cachedEnum);
    } catch (error) {
      console.error(`Failed to cache enums for ${enumType}:`, error);
    } finally {
      delete this.fetchingEnums[enumType];
    }
  }
 
  private isInCache(enumType: string): boolean {
    const cachedEnum = this.cachedEnums.find(
      (cachedItem) => cachedItem.enumType === enumType
    );
    return !Utils.isNullOrUndefined(cachedEnum);
  }
 
import { Pipe } from '@angular/core';
 
enum Alignment {
  left,
  right,
  center,
}
 
export interface IColumnDef {
  columnDisplayName: string;
  propertyName: string;
  formatter?: string;
  zenvyEnumType?: string;
  lookupGroupName?: string;
}
 
 
 
/* error-display.component.scss */
.container-fluid {
  margin-bottom: 0; // Remove margin below the alert
}
 
.alert {
  margin: 0; // Remove margins around the alert
  padding: 0.5rem 1rem; // Adjust padding as needed
}

 
import { Pipe, PipeTransform } from '@angular/core';
import { EnumService } from 'src/app/services/enum.service';
 
@Pipe({
  name: 'enumNamePipe',
})
export class EnumNamePipe implements PipeTransform {
  constructor(private enumService: EnumService) {}
 
  async transform(value: string, enumType?: string): Promise<string> {
    if (enumType) {
      return await this.enumService.getEnumName(value, enumType);
    }
    return '';
  }
}
 
 
 <ng-container *ngIf="column.formatter === 'enumNamePipe'">
        {{
          item[column.propertyName]
            | enumNamePipe : column.zenvyEnumType
            | async
        }}
      </ng-container>
 
  {
      columnDisplayName: 'Frequency',
      propertyName: 'InvoiceGenerationFrequency',
      formatter: 'enumNamePipe',
      zenvyEnumType: 'InvoiceGenerationFrequencies',
    },
 
 
